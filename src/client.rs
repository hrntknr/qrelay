//! Client mode implementation for qrelay.
//!
//! This module implements the TCP listener that accepts local connections and
//! relays data to a QUIC server.

use bytes::{Bytes, BytesMut};
use quinn::{ClientConfig as QuinnClientConfig, Endpoint, RecvStream, SendStream};
use rustls::pki_types::ServerName;
use std::net::SocketAddr;
use std::sync::Arc;
use std::time::Duration;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::net::{TcpListener, TcpStream};
use tokio::sync::{broadcast, Mutex};

use crate::buffer::{RecvBuffer, SendBuffer, SessionState};
use crate::cli::ClientArgs;
use crate::common::{
    build_tls_config, format_duration, parse_connect_address, DnsResolver, READ_BUFFER_SIZE,
};
use crate::error::{Error, Result};
use crate::protocol::Frame;
use crate::session::SESSION_ID_SIZE;

/// Client session for managing a single TCP connection.
struct ClientSession {
    /// Session ID (generated by server, stored after initial connection).
    session_id: [u8; SESSION_ID_SIZE],
    /// Buffer for outgoing data (client -> server).
    send_buffer: SendBuffer,
    /// Buffer for incoming data (server -> client).
    recv_buffer: RecvBuffer,
    /// Resume token received from server.
    resume_token: Option<Bytes>,
    /// Current session state.
    state: SessionState,
}

impl ClientSession {
    /// Creates a new client session.
    fn new(max_buffer_bytes: u64) -> Self {
        Self {
            session_id: [0u8; SESSION_ID_SIZE],
            send_buffer: SendBuffer::new(max_buffer_bytes),
            recv_buffer: RecvBuffer::new(max_buffer_bytes),
            resume_token: None,
            state: SessionState::Init,
        }
    }

    /// Sets the session ID.
    #[allow(dead_code)]
    fn set_session_id(&mut self, id: [u8; SESSION_ID_SIZE]) {
        self.session_id = id;
    }

    /// Sets the resume token.
    #[allow(dead_code)]
    fn set_resume_token(&mut self, token: Bytes) {
        self.resume_token = Some(token);
    }

    /// Returns the session state.
    fn state(&self) -> SessionState {
        self.state
    }

    /// Sets the session state.
    fn set_state(&mut self, state: SessionState) {
        self.state = state;
    }
}

/// Runs the qrelay client.
pub async fn run_client(args: &ClientArgs) -> Result<()> {
    // Build TLS configuration
    let tls_config = build_tls_config(args)?;

    // Create QUIC client config
    let mut quinn_config = QuinnClientConfig::new(Arc::new(
        quinn::crypto::rustls::QuicClientConfig::try_from(tls_config)
            .map_err(|e| Error::Config(format!("failed to create QUIC config: {}", e)))?,
    ));

    // Configure transport parameters
    let mut transport_config = quinn::TransportConfig::default();
    transport_config.max_idle_timeout(Some(
        args.idle_timeout
            .try_into()
            .map_err(|_| Error::Config("idle timeout too large".to_string()))?,
    ));
    if !args.keep_alive.is_zero() {
        transport_config.keep_alive_interval(Some(args.keep_alive));
    }
    quinn_config.transport_config(Arc::new(transport_config));

    // Parse listen address
    let listen_addr = parse_listen_address(&args.listen)?;

    // Create TCP listener
    let listener = TcpListener::bind(listen_addr)
        .await
        .map_err(|e| Error::ListenFailed(e.to_string()))?;

    // Print startup message
    print_startup_message(args);

    tracing::info!("Client listening on {}", listen_addr);

    // Create shutdown signal broadcaster
    let (shutdown_tx, _) = broadcast::channel::<()>(1);

    // Track active connection tasks
    let active_connections = Arc::new(Mutex::new(Vec::new()));

    // Create shared DNS resolver for reuse across connections
    let dns_resolver = Arc::new(DnsResolver::new());

    // Accept TCP connections
    loop {
        tokio::select! {
            accept_result = listener.accept() => {
                match accept_result {
                    Ok((tcp_stream, peer_addr)) => {
                        let connect = args.connect.clone();
                        let sni = args.sni.clone();
                        let max_buffer_bytes = args.max_buffer_bytes;
                        let reconnect_interval = args.reconnect_interval;
                        let quinn_config = quinn_config.clone();
                        let conn_shutdown_rx = shutdown_tx.subscribe();
                        let resolver = Arc::clone(&dns_resolver);

                        let handle = tokio::spawn(async move {
                            tracing::info!(?peer_addr, "new TCP connection accepted");

                            // Run connection with shutdown support
                            // shutdown_rx is passed to handle_tcp_connection so it can send CLOSE frame on shutdown
                            let result = handle_tcp_connection(
                                tcp_stream,
                                &connect,
                                sni.as_deref(),
                                max_buffer_bytes,
                                reconnect_interval,
                                quinn_config,
                                conn_shutdown_rx,
                                resolver,
                            )
                            .await;

                            if let Err(e) = result {
                                tracing::error!(?peer_addr, error = %e, "connection error");
                            }
                        });

                        active_connections.lock().await.push(handle);
                    }
                    Err(e) => {
                        tracing::error!(error = %e, "failed to accept TCP connection");
                    }
                }
            }
            _ = tokio::signal::ctrl_c() => {
                tracing::info!("Received SIGINT, initiating graceful shutdown...");

                // Signal all tasks to shutdown
                let _ = shutdown_tx.send(());

                break;
            }
        }
    }

    // Wait for all active connections to finish (with timeout)
    let handles: Vec<_> = {
        let mut conns = active_connections.lock().await;
        std::mem::take(&mut *conns)
    };

    let shutdown_future = async {
        for handle in handles {
            let _ = handle.await;
        }
    };

    // Wait up to 2 seconds for graceful shutdown
    tokio::select! {
        _ = shutdown_future => {}
        _ = tokio::time::sleep(std::time::Duration::from_secs(2)) => {
            tracing::debug!("Shutdown timeout, some connections may not have closed gracefully");
        }
    }

    tracing::info!("Client shutdown complete");

    Ok(())
}

/// Parses a listen address string into a SocketAddr.
fn parse_listen_address(listen: &str) -> Result<SocketAddr> {
    // Handle ":port" format by prepending "0.0.0.0"
    let addr_str = if listen.starts_with(':') {
        format!("0.0.0.0{}", listen)
    } else {
        listen.to_string()
    };

    addr_str
        .parse()
        .map_err(|e| Error::Config(format!("invalid listen address '{}': {}", listen, e)))
}

/// Prints the startup message.
fn print_startup_message(args: &ClientArgs) {
    eprintln!("Starting client...");
    eprintln!("  Listen: {}", args.listen);
    eprintln!("  Connect: {}", args.connect);
    eprintln!("  ALPN: {}", args.alpn);
    eprintln!("  Idle Timeout: {}", format_duration(args.idle_timeout));
    eprintln!("  Keep Alive: {}", format_duration(args.keep_alive));
    eprintln!(
        "  Reconnect Interval: {}",
        format_duration(args.reconnect_interval)
    );
    eprintln!("  Max Buffer Bytes: {}", args.max_buffer_bytes);
}

/// Handles a single TCP connection.
async fn handle_tcp_connection(
    tcp_stream: TcpStream,
    connect: &str,
    sni: Option<&str>,
    max_buffer_bytes: u64,
    reconnect_interval: Duration,
    quinn_config: QuinnClientConfig,
    shutdown_rx: broadcast::Receiver<()>,
    resolver: Arc<DnsResolver>,
) -> Result<()> {
    let (addr, sni_host) = parse_connect_address(connect, sni, &resolver).await?;

    // Create QUIC endpoint for client
    let mut endpoint = Endpoint::client("0.0.0.0:0".parse().unwrap())
        .map_err(|e| Error::QuicConnectionFailed(format!("failed to create endpoint: {}", e)))?;

    endpoint.set_default_client_config(quinn_config.clone());

    // Create session
    let session = Arc::new(Mutex::new(ClientSession::new(max_buffer_bytes)));

    // Connect to QUIC server
    let connection = connect_to_server(&endpoint, addr, &sni_host).await?;

    // Set session to active
    session.lock().await.set_state(SessionState::Active);

    // Run relay with reconnection support
    let result = run_relay_with_reconnect(
        tcp_stream,
        connection,
        session.clone(),
        reconnect_interval,
        endpoint,
        addr,
        sni_host,
        shutdown_rx,
    )
    .await;

    // Update session state
    {
        let mut sess = session.lock().await;
        match &result {
            Ok(_) => sess.set_state(SessionState::Closed),
            Err(e) => {
                tracing::debug!(error = %e, "session ended with error");
                sess.set_state(SessionState::Closed);
            }
        }
    }

    result
}

/// Connects to the QUIC server.
async fn connect_to_server(
    endpoint: &Endpoint,
    addr: SocketAddr,
    sni_host: &str,
) -> Result<quinn::Connection> {
    let server_name: ServerName<'_> = sni_host
        .to_string()
        .try_into()
        .map_err(|_| Error::Config(format!("invalid SNI hostname: {}", sni_host)))?;

    let connection = endpoint
        .connect(addr, &server_name.to_str())
        .map_err(|e| Error::QuicConnectionFailed(format!("failed to initiate connection: {}", e)))?
        .await
        .map_err(|e| Error::QuicConnectionFailed(format!("connection failed: {}", e)))?;

    tracing::info!(remote = %addr, "connected to QUIC server");

    Ok(connection)
}

/// Runs the relay with reconnection support.
async fn run_relay_with_reconnect(
    tcp_stream: TcpStream,
    initial_connection: quinn::Connection,
    session: Arc<Mutex<ClientSession>>,
    reconnect_interval: Duration,
    endpoint: Endpoint,
    server_addr: SocketAddr,
    sni_host: String,
    mut shutdown_rx: broadcast::Receiver<()>,
) -> Result<()> {
    let (tcp_read, tcp_write) = tcp_stream.into_split();
    let tcp_read = Arc::new(Mutex::new(tcp_read));
    let tcp_write = Arc::new(Mutex::new(tcp_write));

    let mut connection = initial_connection;

    loop {
        // Client opens bidirectional stream (client initiates the stream)
        // Use select to allow shutdown during open
        let (send_stream, recv_stream) = tokio::select! {
            result = connection.open_bi() => {
                result.map_err(|e| Error::QuicConnectionFailed(format!("failed to open stream: {}", e)))?
            }
            _ = shutdown_rx.recv() => {
                tracing::info!("Shutdown received while waiting for stream");
                connection.close(0u32.into(), b"client shutting down");
                return Ok(());
            }
        };

        // Wrap send_stream in Arc<Mutex> for shutdown handling
        let send_stream = Arc::new(Mutex::new(send_stream));

        // Check if this is a resume
        let is_resume = {
            let sess = session.lock().await;
            sess.state() == SessionState::Resuming
        };

        if is_resume {
            // Send RESUME_REQ with shutdown support
            let resume_result = tokio::select! {
                result = send_resume_request(&session, send_stream.clone(), recv_stream, tcp_write.clone()) => result,
                _ = shutdown_rx.recv() => {
                    tracing::info!("Shutdown received during resume request");
                    send_close_frame(&send_stream, "client shutting down").await;
                    return Ok(());
                }
            };

            match resume_result {
                Ok((recv_stream, initial_buffer)) => {
                    // Resume successful, run relay
                    let relay_result = run_relay(
                        tcp_read.clone(),
                        tcp_write.clone(),
                        send_stream,
                        recv_stream,
                        session.clone(),
                        initial_buffer,
                        shutdown_rx.resubscribe(),
                    )
                    .await;

                    match relay_result {
                        Ok(_) => return Ok(()),
                        Err(Error::SessionClosed(reason)) => {
                            tracing::info!(reason, "session closed normally, not reconnecting");
                            connection.close(0u32.into(), b"session closed");
                            return Ok(());
                        }
                        Err(e) => {
                            tracing::warn!(error = %e, "relay disconnected, attempting reconnect");
                            session.lock().await.set_state(SessionState::Disconnected);
                        }
                    }
                }
                Err(Error::ResumeRejected(reason)) => {
                    tracing::error!(reason = %reason, "resume rejected by server");
                    return Err(Error::ResumeRejected(reason));
                }
                Err(e) => {
                    tracing::warn!(error = %e, "resume failed, attempting reconnect");
                    session.lock().await.set_state(SessionState::Disconnected);
                }
            }
        } else {
            // New connection: send CONNECT_REQ first, then receive SESSION_INIT
            let connect_result = tokio::select! {
                result = send_connect_request(&send_stream) => result,
                _ = shutdown_rx.recv() => {
                    tracing::info!("Shutdown received during connect request");
                    send_close_frame(&send_stream, "client shutting down").await;
                    return Ok(());
                }
            };
            connect_result?;

            // Now receive SESSION_INIT
            let init_result = tokio::select! {
                result = receive_session_init(recv_stream, &session) => result,
                _ = shutdown_rx.recv() => {
                    tracing::info!("Shutdown received during session init");
                    send_close_frame(&send_stream, "client shutting down").await;
                    return Ok(());
                }
            };

            let (recv_stream, initial_buffer) = init_result?;

            // Normal relay
            let relay_result = run_relay(
                tcp_read.clone(),
                tcp_write.clone(),
                send_stream,
                recv_stream,
                session.clone(),
                initial_buffer,
                shutdown_rx.resubscribe(),
            )
            .await;

            match relay_result {
                Ok(_) => return Ok(()),
                Err(Error::SessionClosed(reason)) => {
                    tracing::info!(reason, "session closed normally, not reconnecting");
                    connection.close(0u32.into(), b"session closed");
                    return Ok(());
                }
                Err(e) => {
                    tracing::warn!(error = %e, "relay disconnected, attempting reconnect");
                    session.lock().await.set_state(SessionState::Disconnected);
                }
            }
        }

        // Wait before reconnecting (with shutdown check)
        tokio::select! {
            _ = tokio::time::sleep(reconnect_interval) => {}
            _ = shutdown_rx.recv() => {
                tracing::info!("Shutdown received during reconnect wait");
                return Ok(());
            }
        }

        // Try to reconnect (keep retrying until successful or shutdown)
        session.lock().await.set_state(SessionState::Resuming);

        loop {
            tokio::select! {
                result = connect_to_server(&endpoint, server_addr, &sni_host) => {
                    match result {
                        Ok(new_connection) => {
                            connection = new_connection;
                            tracing::info!("reconnected to QUIC server");
                            break;
                        }
                        Err(e) => {
                            tracing::warn!(error = %e, "reconnection failed, retrying...");
                            tokio::select! {
                                _ = tokio::time::sleep(reconnect_interval) => {}
                                _ = shutdown_rx.recv() => {
                                    tracing::info!("Shutdown received during reconnect retry");
                                    return Ok(());
                                }
                            }
                        }
                    }
                }
                _ = shutdown_rx.recv() => {
                    tracing::info!("Shutdown received during reconnection");
                    return Ok(());
                }
            }
        }
    }
}

/// Sends a CONNECT_REQ frame to the server for new connections.
async fn send_connect_request(send_stream: &Arc<Mutex<SendStream>>) -> Result<()> {
    let frame = Frame::ConnectReq;
    let mut buf = BytesMut::new();
    frame.encode(&mut buf);

    let mut stream = send_stream.lock().await;
    stream
        .write_all(&buf)
        .await
        .map_err(|e| Error::QuicConnectionFailed(format!("failed to send CONNECT_REQ: {}", e)))?;

    tracing::debug!("sent CONNECT_REQ to server");
    Ok(())
}

/// Receives and processes the SESSION_INIT frame from the server.
///
/// Returns the recv_stream and any extra data read beyond the SESSION_INIT frame.
async fn receive_session_init(
    mut recv_stream: RecvStream,
    session: &Arc<Mutex<ClientSession>>,
) -> Result<(RecvStream, BytesMut)> {
    let mut read_buf = BytesMut::with_capacity(READ_BUFFER_SIZE);
    let mut tmp_buf = [0u8; READ_BUFFER_SIZE];

    loop {
        // Try to decode a frame
        if let Some((frame, consumed)) =
            Frame::decode(&read_buf).map_err(|e| Error::QuicConnectionFailed(e.to_string()))?
        {
            let _ = read_buf.split_to(consumed);

            match frame {
                Frame::SessionInit { session_id, token } => {
                    tracing::debug!(session_id = ?session_id, "received SESSION_INIT from server");

                    // Store session ID and token
                    {
                        let mut sess = session.lock().await;
                        sess.set_session_id(session_id);
                        sess.set_resume_token(token);
                    }

                    return Ok((recv_stream, read_buf));
                }
                _ => {
                    return Err(Error::QuicConnectionFailed(format!(
                        "expected SESSION_INIT frame, got {:?}",
                        frame
                    )));
                }
            }
        }

        // Read more data
        let n = recv_stream
            .read(&mut tmp_buf)
            .await
            .map_err(|e| Error::QuicConnectionFailed(format!("QUIC read error: {}", e)))?;

        match n {
            Some(0) | None => {
                return Err(Error::QuicConnectionFailed(
                    "connection closed before receiving SESSION_INIT".to_string(),
                ));
            }
            Some(n) => {
                read_buf.extend_from_slice(&tmp_buf[..n]);
            }
        }
    }
}

/// Sends a RESUME_REQ and handles the response.
async fn send_resume_request(
    session: &Arc<Mutex<ClientSession>>,
    send_stream: Arc<Mutex<SendStream>>,
    mut recv_stream: RecvStream,
    _tcp_write: Arc<Mutex<tokio::net::tcp::OwnedWriteHalf>>,
) -> Result<(RecvStream, BytesMut)> {
    let (session_id, last_offset, token) = {
        let sess = session.lock().await;
        let token = sess.resume_token.clone().unwrap_or_default();
        (sess.session_id, sess.recv_buffer.acked_offset(), token)
    };

    // Send RESUME_REQ
    let resume_req = Frame::ResumeReq {
        session_id,
        last_offset,
        token,
    };
    let mut buf = BytesMut::new();
    resume_req.encode(&mut buf);

    send_stream
        .lock()
        .await
        .write_all(&buf)
        .await
        .map_err(|e| Error::QuicConnectionFailed(format!("failed to send RESUME_REQ: {}", e)))?;

    // Read response
    let mut read_buf = BytesMut::with_capacity(READ_BUFFER_SIZE);
    let mut tmp_buf = [0u8; READ_BUFFER_SIZE];

    loop {
        // Try to decode a frame
        if let Some((frame, consumed)) =
            Frame::decode(&read_buf).map_err(|e| Error::QuicConnectionFailed(e.to_string()))?
        {
            let _ = read_buf.split_to(consumed);

            match frame {
                Frame::ResumeOk { start_offset, ack_offset } => {
                    tracing::info!(start_offset, ack_offset, "resume accepted by server");

                    // Retransmit buffered data from ack_offset
                    // ack_offset is the highest offset the server received from us
                    let data_to_send = {
                        let sess = session.lock().await;
                        sess.send_buffer.get_from(ack_offset)
                    };

                    for (offset, data) in data_to_send {
                        let data_frame = Frame::Data { offset, data };
                        let mut frame_buf = BytesMut::new();
                        data_frame.encode(&mut frame_buf);

                        send_stream
                            .lock()
                            .await
                            .write_all(&frame_buf)
                            .await
                            .map_err(|e| {
                                Error::QuicConnectionFailed(format!(
                                    "failed to send retransmit DATA: {}",
                                    e
                                ))
                            })?;
                    }

                    // Set state to active
                    session.lock().await.set_state(SessionState::Active);

                    return Ok((recv_stream, read_buf));
                }
                Frame::ResumeReject { reason } => {
                    return Err(Error::ResumeRejected(reason));
                }
                _ => {
                    tracing::warn!("unexpected frame during resume: {:?}", frame);
                }
            }
        }

        // Read more data
        let n = recv_stream
            .read(&mut tmp_buf)
            .await
            .map_err(|e| Error::QuicConnectionFailed(format!("QUIC read error: {}", e)))?;

        match n {
            Some(0) | None => {
                return Err(Error::QuicConnectionFailed(
                    "connection closed during resume".to_string(),
                ));
            }
            Some(n) => {
                read_buf.extend_from_slice(&tmp_buf[..n]);
            }
        }
    }
}

/// Sends a CLOSE frame to the server.
async fn send_close_frame(send_stream: &Arc<Mutex<SendStream>>, reason: &str) {
    let close_frame = Frame::Close {
        reason: reason.to_string(),
    };
    let mut buf = BytesMut::new();
    close_frame.encode(&mut buf);
    let mut stream = send_stream.lock().await;
    let _ = stream.write_all(&buf).await;
    let _ = stream.finish();
    tracing::info!("Sent CLOSE frame: {}", reason);
}

/// Runs the bidirectional relay between TCP and QUIC streams.
async fn run_relay(
    tcp_read: Arc<Mutex<tokio::net::tcp::OwnedReadHalf>>,
    tcp_write: Arc<Mutex<tokio::net::tcp::OwnedWriteHalf>>,
    send_stream: Arc<Mutex<SendStream>>,
    recv_stream: RecvStream,
    session: Arc<Mutex<ClientSession>>,
    initial_buffer: BytesMut,
    mut shutdown_rx: broadcast::Receiver<()>,
) -> Result<()> {

    // Spawn task for TCP -> QUIC (sending to server)
    let mut tcp_to_quic = {
        let session = Arc::clone(&session);
        let send_stream = Arc::clone(&send_stream);
        let tcp_read = Arc::clone(&tcp_read);

        tokio::spawn(async move { relay_tcp_to_quic(tcp_read, send_stream, session).await })
    };

    // Spawn task for QUIC -> TCP (receiving from server)
    let mut quic_to_tcp = {
        let session = Arc::clone(&session);
        let send_stream = Arc::clone(&send_stream);
        let tcp_write = Arc::clone(&tcp_write);

        tokio::spawn(async move {
            relay_quic_to_tcp(recv_stream, tcp_write, send_stream, session, initial_buffer).await
        })
    };

    // Wait for either task to complete or shutdown signal
    tokio::select! {
        tcp_result = &mut tcp_to_quic => {
            quic_to_tcp.abort();
            tcp_result.map_err(|e| Error::QuicConnectionFailed(format!("relay task panicked: {}", e)))?
        }
        quic_result = &mut quic_to_tcp => {
            tcp_to_quic.abort();
            quic_result.map_err(|e| Error::QuicConnectionFailed(format!("relay task panicked: {}", e)))?
        }
        _ = shutdown_rx.recv() => {
            // Cancel running tasks
            tcp_to_quic.abort();
            quic_to_tcp.abort();

            // Send CLOSE frame on shutdown
            let close_frame = Frame::Close {
                reason: "client shutting down".to_string(),
            };
            let mut buf = BytesMut::new();
            close_frame.encode(&mut buf);
            let mut stream = send_stream.lock().await;
            let _ = stream.write_all(&buf).await;
            let _ = stream.finish();
            tracing::info!("Sent CLOSE frame on shutdown");
            Ok(())
        }
    }
}

/// Relays data from TCP to QUIC.
async fn relay_tcp_to_quic(
    tcp_read: Arc<Mutex<tokio::net::tcp::OwnedReadHalf>>,
    send_stream: Arc<Mutex<SendStream>>,
    session: Arc<Mutex<ClientSession>>,
) -> Result<()> {
    let mut read_buf = [0u8; READ_BUFFER_SIZE];

    loop {
        let n = {
            let mut reader = tcp_read.lock().await;
            reader.read(&mut read_buf).await.map_err(Error::Io)?
        };

        if n == 0 {
            // TCP closed
            tracing::debug!("TCP connection closed");

            // Send CLOSE frame
            let close_frame = Frame::Close {
                reason: "TCP closed".to_string(),
            };
            let mut close_buf = BytesMut::new();
            close_frame.encode(&mut close_buf);

            let _ = send_stream.lock().await.write_all(&close_buf).await;
            break;
        }

        let data = Bytes::copy_from_slice(&read_buf[..n]);

        // Push to send buffer and get offset
        let offset = {
            let mut sess = session.lock().await;
            sess.send_buffer
                .push(data.clone())
                .map_err(|_| Error::BufferLimitExceeded)?
        };

        // Send DATA frame
        let data_frame = Frame::Data { offset, data };
        let mut data_buf = BytesMut::new();
        data_frame.encode(&mut data_buf);

        send_stream
            .lock()
            .await
            .write_all(&data_buf)
            .await
            .map_err(|e| Error::QuicConnectionFailed(format!("failed to send DATA: {}", e)))?;
    }

    Ok(())
}

/// Relays data from QUIC to TCP.
async fn relay_quic_to_tcp(
    mut recv_stream: RecvStream,
    tcp_write: Arc<Mutex<tokio::net::tcp::OwnedWriteHalf>>,
    send_stream: Arc<Mutex<SendStream>>,
    session: Arc<Mutex<ClientSession>>,
    initial_buffer: BytesMut,
) -> Result<()> {
    let mut buffer = initial_buffer;
    let mut read_buf = [0u8; READ_BUFFER_SIZE];

    loop {
        // Try to decode frames from buffer
        while let Some((frame, consumed)) =
            Frame::decode(&buffer).map_err(|e| Error::QuicConnectionFailed(e.to_string()))?
        {
            let _ = buffer.split_to(consumed);

            match frame {
                Frame::Data { offset, data } => {
                    // Insert into receive buffer
                    let ack_offset = {
                        let mut sess = session.lock().await;
                        sess.recv_buffer
                            .insert(offset, data.clone())
                            .map_err(|_| Error::BufferLimitExceeded)?;

                        // Read contiguous data and send to TCP
                        while let Some((data, _)) = sess.recv_buffer.read() {
                            let mut writer = tcp_write.lock().await;
                            writer.write_all(&data).await.map_err(Error::Io)?;
                        }

                        sess.recv_buffer.acked_offset()
                    };

                    // Send ACK
                    let ack_frame = Frame::Ack { offset: ack_offset };
                    let mut ack_buf = BytesMut::new();
                    ack_frame.encode(&mut ack_buf);

                    send_stream.lock().await.write_all(&ack_buf).await.map_err(|e| {
                        Error::QuicConnectionFailed(format!("failed to send ACK: {}", e))
                    })?;
                }
                Frame::Ack { offset } => {
                    // Process ACK - release data from send buffer
                    let mut sess = session.lock().await;
                    sess.send_buffer.ack(offset);
                }
                Frame::Close { reason } => {
                    tracing::info!(reason, "received CLOSE frame from server");
                    return Err(Error::SessionClosed(reason));
                }
                Frame::ResumeOk { .. } | Frame::ResumeReject { .. } => {
                    // These should only be received during resume handshake
                    tracing::warn!("unexpected resume frame during relay");
                }
                Frame::ResumeReq { .. } => {
                    // Client should not receive RESUME_REQ
                    tracing::warn!("unexpected RESUME_REQ frame");
                }
                Frame::SessionInit { .. } => {
                    // SESSION_INIT should only be received at connection start
                    tracing::warn!("unexpected SESSION_INIT frame during relay");
                }
                Frame::ConnectReq => {
                    // Client should not receive CONNECT_REQ
                    tracing::warn!("unexpected CONNECT_REQ frame");
                }
            }
        }

        // Read more data from QUIC
        let n = recv_stream
            .read(&mut read_buf)
            .await
            .map_err(|e| Error::QuicConnectionFailed(format!("QUIC read error: {}", e)))?;

        match n {
            Some(0) | None => {
                tracing::debug!("QUIC stream closed");
                break;
            }
            Some(n) => {
                buffer.extend_from_slice(&read_buf[..n]);
            }
        }
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::error::ExitCode;

    // Note: SecurityMode, parse_connect_address, and format_duration tests
    // are now in common.rs to avoid duplication.

    #[test]
    fn test_parse_listen_address_valid() {
        let addr = parse_listen_address("127.0.0.1:2222").unwrap();
        assert_eq!(addr.port(), 2222);
        assert_eq!(addr.ip(), std::net::Ipv4Addr::new(127, 0, 0, 1));
    }

    #[test]
    fn test_parse_listen_address_port_only() {
        let addr = parse_listen_address(":2222").unwrap();
        assert_eq!(addr.port(), 2222);
        assert_eq!(addr.ip(), std::net::Ipv4Addr::new(0, 0, 0, 0));
    }

    #[test]
    fn test_parse_listen_address_invalid() {
        let result = parse_listen_address("invalid");
        assert!(result.is_err());
    }

    #[test]
    fn test_client_session_new() {
        let session = ClientSession::new(1024);
        assert_eq!(session.state(), SessionState::Init);
        assert_eq!(session.session_id, [0u8; SESSION_ID_SIZE]);
        assert!(session.resume_token.is_none());
    }

    #[test]
    fn test_client_session_state_transitions() {
        let mut session = ClientSession::new(1024);
        assert_eq!(session.state(), SessionState::Init);

        session.set_state(SessionState::Active);
        assert_eq!(session.state(), SessionState::Active);

        session.set_state(SessionState::Disconnected);
        assert_eq!(session.state(), SessionState::Disconnected);

        session.set_state(SessionState::Resuming);
        assert_eq!(session.state(), SessionState::Resuming);

        session.set_state(SessionState::Closed);
        assert_eq!(session.state(), SessionState::Closed);
    }

    #[test]
    fn test_client_session_set_session_id() {
        let mut session = ClientSession::new(1024);
        let id = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];
        session.set_session_id(id);
        assert_eq!(session.session_id, id);
    }

    #[test]
    fn test_client_session_set_resume_token() {
        let mut session = ClientSession::new(1024);
        let token = Bytes::from_static(b"test_token");
        session.set_resume_token(token.clone());
        assert_eq!(session.resume_token, Some(token));
    }

    #[test]
    fn test_exit_code_values() {
        assert_eq!(ExitCode::Success as i32, 0);
        assert_eq!(ExitCode::ListenFailed as i32, 10);
        assert_eq!(ExitCode::QuicConnectionFailed as i32, 11);
        assert_eq!(ExitCode::TlsVerificationFailed as i32, 12);
        assert_eq!(ExitCode::BufferLimitExceeded as i32, 20);
        assert_eq!(ExitCode::ResumeRejected as i32, 21);
    }
}
